class Entrada:
    def __init__(self, tamaño_muestra: int, a: float, b: float, f: str):
        assert tamaño_muestra > 0, "Valor de tamaño de muestra inválido" # Tiene que haber al menos una muestra porque no tiene chiste hacer el código sin muestras
        assert a < b, "a debe ser menor que b" # El límite inferior debe ser menor al superior
        
        # Aseguramos que sean del tipo que necesitamos
        self.tamaño_muestra = int(tamaño_muestra)
        self.a = float(a)
        self.b = float(b)
        self.f = f

    # La función 1 / (e^x + e^-x) 
    def f1(self, x):
        return 1 / (np.exp(x) + np.exp(-x))
    
    # La función 2 / (e^x + e^-x) 
    def f2(self, x):
        return 2 / (np.exp(x) + np.exp(-x))

    # Función para generar muestras aleatorias
    def muestra_aleatoria(self):

        # Listas vacías para guardar los resultados
        muestras = []
        valores_a = []
        valores_b = []
        valores_x = []
        valores_y = []
        valores_estimados = []

        b_a = (self.b - self.a) # b-a para aproximar la integral en toda el área

        for i in range(self.tamaño_muestra): # Cantidad de muestras
            x = np.random.uniform(self.a, self.b) # Número aleatorio entre los límites

            if self.f == 'a':
                y = self.f1(x) # Evaluar x en la función
            elif self.f == 'b':
                y = self.f2(x) 
            else:
                raise ValueError("Funciones válidas: 'a' y 'b'")

            integral_estimada = b_a * y # Estimamos la integral como (b-a)/n * f(x)

            # Añadimos los valores a las listas y repetimos hasta llegar al número de muestras
            muestras.append(i + 1)
            valores_a.append(self.a)
            valores_b.append(self.b)
            valores_x.append(x)
            valores_y.append(y)
            valores_estimados.append(integral_estimada)

        # Almacenamos las listas como un dataframe
        df = pd.DataFrame({
            'Muestra': muestras,
            'a': valores_a,
            'b': valores_b,
            'x': valores_x,
            'y': valores_y,
            'Integral Estimada': valores_estimados
        })

        return df
